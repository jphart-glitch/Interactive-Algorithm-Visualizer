/* ------------------------------------------------------------------ */
/* Instructions.jsx                                                   */
/* Author: John Hart                                                  */
/* ------------------------------------------------------------------ */

export const all_instructions = {
    MERGESORT : "This Interact module will teach you how merge sort works and how to operate the application, after which you can practice on your own!\n\nMerge sort is a popular and very important algorithm known for having the most efficient worst case run time of the classical sorting algorithms. The algorithm functions are less intuitive when described in text, but are nonetheless important to understand. The algorithm splits the array into subarrays of size 2 (if it is an odd length array, one subarray will simply have 1 element), sorts the small subarrays, then merges pairs of subarrays into new arrays. This \”merge\” step consists of recursively selecting the smallest element of the two subarrays until both subarrays are empty. For example, when merging subarrays [1, 3] and [2, 4], the algorithm will select values in the order of 1, 2, 3, and 4 and place them in the new array. This process of merging will occur recursively until the algorithm is left with one correctly sorted array!\n\nThis algorithm does not have a very special best or average case – they are all iterations of the worst case run time of O(nlogn). We will not show a proof, but we do suggest thinking why intuitively the algorithm would have this run time and exploring further (a good place to start is to think about how many arrays will be used and how many times an element will be checked using a compare operation). Regardless, O(nlogn) is a very good worst case run time – in fact, it is the best of the classical sorting algorithms (if you want something with a better worst case, look into non-conventional sorts like radix sort).\n\nNow that you understand the basics of the algorithm, let\'s put that knowledge into practice by sorting the array on the page! To do this, you are given a few tools. First off, you are able to move elements around in an array via dragging and dropping. You are given three arrays: the start/destination array and two merging subarrays. Since the subarray is of length 4, we ask that you place all elements in the first subarray, sort the first two elements, sort the final two elements, perform a \“pseudo-merge\” inside of the subarray, and then do the same for the second subarray. After both subarrays are sorted, you should perform a merge into the start/destination array as would occur normally. After performing each step, you should click the button labeled \”Click here to check your state!\”; if you performed the correct step, you will be told so; if you performed the wrong step, the arrays will reset to the state before you made any changes and you will be told to try again. To help you keep track of what step you are on, you may click the button labeled \”Toggle to see the previous step you took!\” for a brief description of the action you just performed. You can access these instructions anytime by clicking the button labeled “Toggle Instructions”.\n\nWhen you\'re ready, feel free to click the button down below!",
    INSERTIONSORT : "This Interact module will teach you how insertion sort works and how to operate the application, after which you can practice on your own!\n\nInsertion sort is a simple algorithm with a fairly good best case run time but a bad worst case run time. The algorithm\’s functions are fairly simple: continually move right in the array and swap down elements that are smaller than the element to the left of it. In more formal terms, the algorithm in iteration i looks at the ith element in the array (array[i]) and checks the element to the left of it; if array[i] < array[i - 1], swap the two and check array[i - 1] against array[i - 2] until the end of the array is reached or it is in the correct spot (relatively); afterwards, go through the next iteration. For example, in iteration 2, the algorithm will compare array[2] with array[1]; if array[2] < array[1], swap values of array[1] and array[2] and compare array[1] with array[0], swapping them as well if necessary. The algorithm will continue this until the array is fully sorted!\n\nWhile this will be better than other sorting algorithms in certain situations (its best case run time is O(n) – not bad!), this algorithm has a particularly bad worst case run time. For example, consider the array [4, 3, 2, 1]. In this case, the algorithm will have to compare and swap every element to the left of index i in the array during each iteration. Insertion sort can take O(n^2) time, which is rather inefficient compared to other sorting algorithms.\n\nNow that you understand the basics of the algorithm, let\'s put that knowledge into practice by sorting the array on the page! To do this, you are given a few tools. First off, you are able to move elements around in an array via dragging and dropping. You are only given one array, so you must move elements around within the same array. Make sure to perform adjacent swaps only, as that is how the algorithm functions! After performing each step, you should click the button labeled \”Click here to check your state!\”; if you performed the correct step, you will be told so; if you performed the wrong step, the arrays will reset to the state before you made any changes and you will be told to try again. To help you keep track of what step you are on, you may click the button labeled \”Toggle to see the previous step you took!\” for a brief description of the action you just performed. You can access these instructions anytime by clicking the button labeled “Toggle Instructions”.\n\nWhen you\'re ready, feel free to click the button down below!",
    SELECTIONSORT : "This Interact module will teach you how selection sort works and how to operate the application, after which you can practice on your own!\n\nSelection sort is one of the more intuitive classical sorting algorithms in that all the algorithm does is go through each index and swap the correct element into it. In more formal terms, the algorithm in iteration i keeps track of the \“next\” minimum element in the array, swaps the minimum element into array[i], and continues onto the next iteration. For example, in iteration 0, the algorithm will look through the entire array to find the smallest element, \“select\” it, and swap it into index 0 (i.e. swap array[0] and array[min]). The algorithm will continue this until the array is fully sorted!\n\nAs you are likely imagining, this is not the most efficient way to go about sorting an array. For example, consider the array [2, 3, 4, 1]. In this case, the algorithm will have to look at every element to the right of index i in the array during each iteration. Selection sort can take O(n^2) time, which is rather inefficient compared to other sorting algorithms.\n\nNow that you understand the basics of the algorithm, let\'s put that knowledge into practice by sorting the array on the page! To do this, you are given a few tools. First off, you are able to move elements around in an array via dragging and dropping. You are also able to move elements between two different arrays: the start/destination array and the selection array. Since you cannot directly swap elements via dragging and dropping, you will place the element you want to swap into the selection array (i.e. place element at index i into the selection array if it is out of place), swap the correct element into index i, and put the element in the selection array into the old place of the current correct element. After performing each step, you should click the button labeled \”Click here to check your state!\”; if you performed the correct step, you will be told so; if you performed the wrong step, the arrays will reset to the state before you made any changes and you will be told to try again. To help you keep track of what step you are on, you may click the button labeled \”Toggle to see the previous step you took!\” for a brief description of the action you just performed. You can access these instructions anytime by clicking the button labeled “Toggle Instructions”.\n\nWhen you\'re ready, feel free to click the button down below!",
    STACKS : "This Interact module will teach you how stacks work and how to operate the application, after which you can practice on your own!\n\nStacks are a very common data structure that store a collection of objects. Stacks function by keeping the objects in a last-in-first-out (LIFO) ordered pile, where one is allowed to take items off of or place new items on the top of the pile. The most basic stack will contain two operations: push(x) – push object x onto the top of the stack; pop() – remove the object on the top of the stack and return it. Stacks are formed and modified through a mix of these operations, and some implementations of stacks will contain other operations such as peek() and iterate().\n\nStacks can be implemented either using an array or a linked list, but the run time for both implementations of push(x) and pop() will be constant (O(1) run time)! This makes stacks at their most basic form a very powerful data structure to store data in, as the basic operations are very fast. Stacks are also very adaptable and can be improved upon to form more complex data structures or can even be used to implement certain algorithms!\n\nNow that you understand the basics of the algorithm, let\'s put that knowledge into practice by performing a medley of stack operations! Here are the operations you are tasked with performing:\n\nPush 1; Push 2; Pop; Push 4; Pop; Push 8; Push 6; Pop; Pop; Push 5; Pop; Pop; Push 7; Push 3; Pop; Pop.\n\nTo perform these operations, you are given a few tools. First off, you are able to move elements inside of and between sections via dragging and dropping. You are given three sections; from left to right, they are: the input section, the stack section, and the output section. To perform the push(x) operation, take the correct element and place it at the top of the stack section; to perform the pop() operation, take the element at the top of the stack and place it at the end of the output section. After performing each step, you should click the button labeled \”Click here to check your state!\”; if you performed the correct step, you will be told so; if you performed the wrong step, the arrays will reset to the state before you made any changes and you will be told to try again. To help you keep track of what step you are on, you may click the button labeled \”Toggle to see the previous step you took!\” for a brief description of the action you just performed. You can access these instructions anytime by clicking the button labeled “Toggle Instructions”.\n\nWhen you\'re ready, feel free to click the button down below!",
    QUEUES : "This Interact module will teach you how queues work and how to operate the application, after which you can practice on your own!\n\nQueues are a common data structure that store a collection of objects. Queues function almost like a reverse-stack by keeping the objects in a first-in-first-out (FIFO) ordered pile (as opposed to a stack\’s LIFO pile), where one is allowed to take items off of the bottom of the pile or place new items on the top of the pile. The most basic stack will contain two operations: enqueue(x) – push object x onto the top of the queue; pop() – remove the object on the bottom of the queue and return it. Queues, like stacks, are formed and modified through a mix of these operations, and most queue implementations will actually involve using a stack or two!\n\nQueues can be implemented either using a resizing array or a linked list, but the run time for both implementations of enqueue(x) and dequeue() will be constant (O(1) run time)! This makes queues another very powerful data structure to store data in, as the basic operations are very fast. Queues, like stacks, are also very adaptable and can be improved upon to form more complex data structures or can even be used to implement certain algorithms!\n\nNow that you understand the basics of the algorithm, let\'s put that knowledge into practice by performing a medley of queue operations! Here are the operations you are tasked with performing:\n\nEnqueue 1; Enqueue 2; Dequeue; Enqueue 4; Dequeue; Enqueue 8; Enqueue 6; Dequeue; Dequeue; Enqueue 5; Dequeue; Dequeue; Enqueue 7; Enqueue 3; Dequeue; Dequeue.\n\nTo perform these operations, you are given a few tools. First off, you are able to move elements inside of and between sections via dragging and dropping. You are given three sections; from left to right, they are: the input section, the queue section, and the output section. To perform the enqueue(x) operation, take the correct element and place it at the top of the queue section; to perform the dequeue() operation, take the element at the bottom of the queue and place it at the end of the output section. After performing each step, you should click the button labeled \”Click here to check your state!\”; if you performed the correct step, you will be told so; if you performed the wrong step, the arrays will reset to the state before you made any changes and you will be told to try again. To help you keep track of what step you are on, you may click the button labeled \”Toggle to see the previous step you took!\” for a brief description of the action you just performed. You can access these instructions anytime by clicking the button labeled “Toggle Instructions”.\n\nWhen you\'re ready, feel free to click the button down below!",
    PRIORITYQUEUES : "This Interact module will teach you how priority queues work and how to operate the application, after which you can practice on your own!\n\nPriority queues are a variant of stacks/queues that can allow one to access certain elements as needed. Priority queues are most commonly implemented as minimum/maximum PQs, meaning that they allow one to delete the max/min in the collection of objects. For a min PQ (what we will be looking at in this module), the most basic operations are: insert(x) – push object x onto the top of the queue; delMin() – remove the minimum object of the queue and return it. Priority queues are a different twist on normal stack and queue implementations and can be utilized to make accessing certain elements easier!\n\nPriority queues are often implemented using binary heaps. This implementation allows O(logn) run time for insert(x) and delMin() operations – a downgrade from operations like pop() and push(x), but a necessary sacrifice nonetheless for getting a specific element reliably. Our implementation, however, will be using an unordered linked-list queue implementation, meaning that the delMin() operation will have a worst-case run time of O(n). While our implementation will not be the most efficient, it will still serve as a good example of how a priority queue would function!\n\nNow that you understand the basics of the algorithm, let\'s put that knowledge into practice by performing a medley of min PQ operations! Here are the operations you are tasked with performing:\n\nInsert 1; Insert 2; DelMin; Insert 4; DelMin; Insert 8; Insert 6; DelMin; DelMin; Insert 5; DelMin; DelMin; Insert 7; Insert 3; DelMin; DelMin.\n\nTo perform these operations, you are given a few tools. First off, you are able to move elements inside of and between sections via dragging and dropping. You are given three sections; from left to right, they are: the input section, the queue section, and the output section. To perform the insert(x) operation, take the correct element and place it at the top of the queue section; to perform the delMin() operation, take the minimum element in the queue and place it at the end of the output section. After performing each step, you should click the button labeled \”Click here to check your state!\”; if you performed the correct step, you will be told so; if you performed the wrong step, the arrays will reset to the state before you made any changes and you will be told to try again. To help you keep track of what step you are on, you may click the button labeled \”Toggle to see the previous step you took!\” for a brief description of the action you just performed. You can access these instructions anytime by clicking the button labeled “Toggle Instructions”.\n\nWhen you\'re ready, feel free to click the button down below!",
    TWOTHREETREES : "There will be instructions here!",
}